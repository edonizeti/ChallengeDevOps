## Second Challenge

Let's start decoupling our architecture.\
In the first challenge, we created and deployed our application using an EC2.\
In this session, we've learnt a bit about ALB and RDS and in the next challenge, we will be making use of these resources.

<img src="./assets/challenge_2.png" alt="first" width="800px"/>


### Below, a summary of your next tasks:

|  | Task |
|------|-------------|
|1|Create a Private Subnet in your VPC |
|2|Create a new Ubuntu Server using EC2 in the private Subnet |
|3|Create an RDS for MySQL also in the private Subnet |
|4|Create an Application Load Balancer in the public Subnet|
|5|Install All the necessary dependencies in the EC2, and deploy your laravel application. However, your MySQL will be now in RDS instead of installed in the EC2.|
|6|To access your application, we should go now through the ALB.|
|7|See you next session :)|


<br>

# Creating Private and Public Subnets

To meet one of the requirements of this challenge, it will be necessary to use an ALB (Application Load Balancer). To configure an ALB, you need to use at least two Availability Zones, because if one of the zones goes down, the ALB will direct all traffic to the other. Following the challenge requirements, you need to create 2 subnets in each AZ (one public and one private).

## - Create the Public Subnets 

A public subnet is a subnet that is associated with a route table that has a route to an Internet gateway. Internet gateway connects the VPC to the Internet and to other AWS services. The resources in the public subnet can send outbound traffic directly to the Internet and vice versa. 

Let's create one more public subnet by selecting the **Subnets** tab from the left sidebar in the VPC section and clicking on the **Create Subnet** button.

>You must select a different Availability Zone (AZ) for each public subnet.

Once done, click on the **Create** button to create the subnet.

After creating the subnet, select it and click on **Actions** at the top of the screen. Then, choose **Edit subnet settings**, select the **Enable auto-assign public IPv4 address** option, and click **Save**.

>By default, subnets have the **Auto-Assign Public IP** setting as disabled.

<br>

    VPC ID: "dnx-vpc"
    Name: "dnx-public-subnet"
    Availability Zone: "us-eats-1a"
    Pv4 CIDR block: "10.100.11.0/24"
    Enable auto-assign public IPv4 address: "True"
    
    Tags:
    - Name: "dnx-public-subnet"
    - Environment: "Challenge-DevOps"

<br>

    VPC ID: "dnx-vpc"
    Name: "dnx-public-subnet2"
    Availability Zone: "us-eats-1b"
    Pv4 CIDR block: "10.100.12.0/24"
    Enable auto-assign public IPv4 address: "True"
    
    Tags:
    - Name: "dnx-public-subnet2"
    - Environment: "Challenge-DevOps"

In a similar way, you can now create the private subnets.

## - Create the Private Subnets 

A private subnet is a subnet that is associated with a route table that doesn’t have a route to an internet gateway. Instances in the private subnet are backend servers they don’t accept the traffic from the internet. Resources like database may require connection to internet for updates/patches but should not be accepting request from the internet.

>The procedure for creating the private subnets is the same as for creating public subnets, however you must not enable the option Enable auto-assign public IPv4 address.

<br>

    VPC ID: "dnx-vpc"
    Name: "dnx-private-subnet"
    Availability Zone: "us-eats-1a"
    Pv4 CIDR block: "10.100.21.0/24"
    
    Tags:
    - Name: "dnx-private-subnet"
    - Environment: "Challenge-DevOps"

<br>

    VPC ID: "dnx-vpc"
    Name: "dnx-private-subnet2"
    Availability Zone: "us-eats-1b"
    Pv4 CIDR block: "10.100.22.0/24"
    
    Tags:
    - Name: "dnx-private-subnet2"
    - Environment: "Challenge-DevOps"

<br>

# Route Tables

To meet another of the requirements of this challenge, 2 route tables are required (one for the public subnets and the other for the private subnets). As we already have a public route table, let's now create a private route table.

Let's head to the **Route Tables** tab from the left sidebar and click on the **Create route table** button at the top.

>For security reasons, it is recommended to leave the main route table as it is. Hence, we will be creating a new route table for our custom VPC and allow internet access to our public subnet through it.

<br>

## - Associating subnets with the Route Tables

By default, all subnets are associated with the main route table. Let's associate the public subnets with the public route table and the private subnets with the private route table by selecting the rote tables and navigating to the **Subnet Associations** tab at the bottom.

Click on the **Edit subnet associations** and select the subnets (according to the type of route table) and click on the **Save** button.

<br>

    VPC ID: "dnx-vpc"
    Explicit subnet associations: "dnx-public-subnet", "dnx-public-subnet2"
    Routes:
    - Destination: "0.0.0.0/0" | Target: "dnx-igw"
    - Destination: "10.100.0.0/16" | Target: "local"

    Tags:
    - Name: "dnx-rtb"
    - Environment: "Challenge-DevOps"

<br>

        VPC ID: "dnx-vpc"
    Explicit subnet associations: "dnx-private-subnet", "dnx-private-subnet2"
    Routes:
    - Destination: "10.100.0.0/16" | Target: "local"

    Tags:
    - Name: "dnx-rtb-private"
    - Environment: "Challenge-DevOps"

<br>

# Security Groups

Now let's create the security groups. For this challenge you will need 4 security groups. One for the application server, one for the ALB, one for the RDS and finally one for our NAT Instance. Both for the Application Server and for the NAT instance we will open port 22 so that we can configure our application.

<br>

    Security group name: "dnx-alb-scg"
    Description: "Allow acess to ALB"
    VPC ID: "dnx-vpc"

    Inbound rules:
    - Type: HTTP        | Protocol: TCP | Source type: My IP | Source: "you IP address"
        
    Outbound rules:
    - Type: All traffic | Protocol: All | Destination: "0.0.0.0/0"
        
    Tags:
    - Name: "dnx-alb-scg"
    - Environment: "Challenge-DevOps"

<br>

    Security group name: "dnx-nat-scg"
    Description: "Allow acess to EC2 NAT Instance"
    VPC ID: "dnx-vpc"

    Inbound rules:
    - Type: SSH         | Protocol: TCP | Source type: My IP | Source: "you IP address"
    - Type: HTTP        | Protocol: TCP | Source: "dnx-svr-scg"  
        
    Outbound rules:
    - Type: All traffic | Protocol: All | Destination: "0.0.0.0/0"
        
    Tags:
    - Name: "dnx-nat-scg"
    - Environment: "Challenge-DevOps"

<br>

    Security group name: "dnx-svr-scg"
    Description: "Allow acess to private EC2 Instances"
    VPC ID: "dnx-vpc"

    Inbound rules:
    - Type: SSH     | Protocol: TCP | Source: "dnx-nat-scg"
    - Type: HTTP    | Protocol: TCP | Source: "dnx-alb-scg"
        
    Outbound rules:
    - Type: All traffic | Protocol: TCP | Destination: "0.0.0.0/0"
        
    Tags:
    - Name: "dnx-scg"
    - Environment: "Challenge-DevOps"

<br>

    Security group name: "dnx-rds-scg"
    Description: "Allow acess to RDS"
    VPC ID: "dnx-vpc"

    Inbound rules:
    - Type: MYSQL/Aurora   | Protocol: TCP | Source: "dnx-svr-scg"
        
    Outbound rules:
    - Type: All traffic | Protocol: All | Destination: "0.0.0.0/0"
        
    Tags:
    - Name: "dnx-rds-scg"
    - Environment: "Challenge-DevOps"

<br>

# Private EC2 Instance (Ubuntu Server)

It's time to launch your private instance. Head over to the EC2 dashboard and click on **Launch Instance**. Select the **Ubuntu Server 22.04 LTS** and choose an instance type (t2.micro is available in the Free Tier)

In the next step select the Key pair, the custom VPC, the private subnet and the security group (select existing security group and choose the security group that you have created before).

Now, add some storage and give some name to your instance.

    Application and OS Images: "Ubuntu, 22.04 LTS"
    Instance type: "t2.micro"
    Key pair: "dnx-key-pair"
    VPC ID: "dnx-vpc"
    Subnet: "dnx-private-subnet"
    Auto-assign public IP: "Disable"
    Security groups: "dnx-svr-scg"
    Configure storage: "8 GiB gp2"

    Tags:
    - Name: "dnx-svr-private"
    - Environment: "Challenge-DevOps"

<br>

# NAT Instance and Bastion Host

Private subnets in an AWS VPC must be associated with a NAT gateway or a NAT instance to be able to access the internet. A NAT gateway will always be the best choice for a production environment - they are managed, highly scalable, and highly available. But NAT instances are still a good option for who want to minimize their monthly cloud bill.

NAT instances were the old way to provide internet connectivity to the instances. An intance behind a NAT can initiate a connection to internet, but an new connection attempt from internet to the instance would be blocked. NAT allows intances to open connections to internet but not the other way around.

A Bastion host is a special-purpose server or an instance that is used to configure to work against the attacks or threats. It is also known as the ‘jump box’ that acts like a proxy server and allows the client machines to connect to the remote server. It is basically a gateway between the private subnet and the internet. It allows the user to connect private network from an external network and act as  proxy to other instances. 

Head over to the EC2 dashboard and click on **Launch Instance**. Select the **Amazon Linux 2023 AMI** and choose an instance type. In the next step select the Key pair, the custom VPC as the network, the public subnet and the security group.

In advanced details, go to "User Data" and paste the following script to install and configure the IPTables.

```bash
sudo sysctl -w net.ipv4.ip_forward=1
sudo /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
sudo yum install iptables-services
sudo service iptables save
```
Then click on **Launch Instance**.


    Application and OS Images: "Amazon Linux 2023 AMI"
    Instance type: "t2.micro"
    Key pair: "dnx-key-pair"
    VPC ID: "dnx-vpc"
    Subnet: "dnx-public-subnet"
    Auto-assign public IP: "Enable"
    Security groups: "dnx-nat-scg"
    Configure storage: "8 GiB gp2"

    User Data:
        sudo sysctl -w net.ipv4.ip_forward=1
        sudo /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
        sudo yum install iptables-services
        sudo service iptables save

    Tags:
    - Name: "dnx-svr-private"
    - Environment: "Challenge-DevOps"

<br>

# Update the private route table

After creating the NAT Instance, it is necessary to adjust the private route table. To do this, go to **VPC** then **Route Tables**. Select the **Private Route Table** and in the routes tab select **Edit routes**. Specify **0.0.0.0/0** for **Destination** and the **instance ID** of the **NAT instance (dnx-nat-inst)** for **Target**.

<br>

# Listeners, Routing and Target Group

A listener is a process that checks for connection requests, using the protocol and port you configure while creating your AWS Application Load Balancer.

Target groups route requests to one or more registered targets, such as EC2 instances, using the protocol and port number that you specify. You can register a target with multiple target groups. You can configure health checks on a per target group basis. Health checks are performed on all targets registered to a target group that is specified in a listener rule for your load balancer.

For creating a new Target Group you will click on **Create a target group**. Note that here traffic on port 80 will be forwarded to the Target Group created.

First, you will specify group details. Note that our load balancer will route requests to the targets in a target group and performs health checks on the targets as well. Targets can be of different types such as **Instances, IP addresses, Lambda function,** and even an AWS **Application Load Balancer**. We will keep our target to be **Instances** that we created above. Give a name to the Target Group, select the VPC and leave the other options in default and click next.

The next step is to register the targets. Here you can see the instances you created previously. Select the **EC2 private Instance** and click on **Include as pending below** then click on **Create target group**

<br>

# Application Load Balancer

The Application Load Balancer distributes incoming HTTP and HTTPS traffic across multiple targets such as Amazon EC2 instances, microservices, and containers, based on request attributes. When the load balancer receives a connection request, it evaluates the listener rules in priority order to determine which rule to apply, and if applicable, it selects a target from the target group for the rule action.

On EC2, in the left pane, click **Load Balancers** then click on **Create load balancer**. Here you can find four types of Load Balancers. Select **Aplication Load Balancer** and click on **Create**.

Here you will provide the name of your Load Balancer and you will keep it to be **Internet-facing** as you want your load balancer to route requests from clients over the internet to target that in your case will be the EC2 instances. You can select the type of **IP addresses** that your subnets will use, for now, you will leave it to **IPV4**.

Now you will select at least two Availability Zones and one subnet per zone so that the load balancer will route traffic to targets in these Availability Zones only. Select the
ALB security group created previously.

In **Listeners and routing**, select the **Target Group** created earlier. Finally, click on **Create load balancer**

<br>

### Target Group

    Target type: Instances
    Target group name: "dnx-private-trg"
    Protocol: "HTTP"
    Port: "80"
    VPC: "dnx-vpc"
    Protocol version: "HTTP1"
    Health check protocol: "HTTP"
    Health check path: "/"
    Instances: dnx-svr-private
    
    Tags:
    - Name: "dnx-private-trg"
    - Environment: "Challenge-DevOps"

<br>

### Load Balancer

    Type: "Application Load Balancer"
    Name: "dnx-alb"
    Scheme: "Internet-facing"
    IP address type: "IPv4"
    VPC: "dnx-vpc"
    Mappings:
    - "ap-southeast-2a - dnx-public-subnet-01"
    - "ap-southeast-2b - dnx-public-subnet-02"

    Security Group: "dnx-alb-scg"
    Listeners and routing
    - "Listener:  HTTP:80  Forward to dnx-private-trg (HTTP)"

    Tags:
    - Name: "dnx-alb"
    - Environment: "Challenge-DevOps"

<br>